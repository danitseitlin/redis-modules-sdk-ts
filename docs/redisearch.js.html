<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: redisearch.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: redisearch.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Redisearch = void 0;
const module_base_1 = require("./module.base");
class Redisearch extends module_base_1.Module {
    constructor(options, moduleOptions, clusterOptions) {
        super(Redisearch.name, options, moduleOptions, clusterOptions);
    }
    /**
     * Creating an index with a given spec
     * @param index The index of the schema
     * @param indexType The index type of the schema
     * @param schemaFields The filter set after the 'SCHEMA' argument
     * @param parameters The additional parameters of the spec
     * @returns 'OK' or error
     */
    create(index, indexType, schemaFields, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [index, 'ON', indexType];
            if (parameters !== undefined) {
                if (parameters.prefix !== undefined) {
                    args.push('PREFIX');
                    for (const prefix of parameters.prefix)
                        args = args.concat([prefix.count.toString(), prefix.name]);
                }
                if (parameters.filter !== undefined)
                    args = args.concat(['FILTER', parameters.filter]);
                if (parameters.language !== undefined)
                    args = args.concat(['LANGUAGE', parameters.language]);
                if (parameters.languageField !== undefined)
                    args = args.concat(['LANGUAGE_FIELD', parameters.languageField]);
                if (parameters.score !== undefined)
                    args = args.concat(['SCORE', parameters.score]);
                if (parameters.scoreField !== undefined)
                    args = args.concat(['SCORE_FIELD', parameters.scoreField]);
                if (parameters.payloadField !== undefined)
                    args = args.concat(['PAYLOAD_FIELD', parameters.payloadField]);
                if (parameters.maxTextFields !== undefined)
                    args = args.concat(['MAXTEXTFIELDS', parameters.maxTextFields.toString()]);
                if (parameters.noOffsets !== undefined)
                    args.push('NOOFFSETS');
                if (parameters.temporary !== undefined)
                    args.push('TEMPORARY');
                if (parameters.nohl !== undefined)
                    args.push('NOHL');
                if (parameters.noFields !== undefined)
                    args.push('NOFIELDS');
                if (parameters.noFreqs !== undefined)
                    args.push('NOFREQS');
                if (parameters.stopwords !== undefined)
                    args = args.concat(['STOPWORDS', parameters.stopwords.num.toString(), parameters.stopwords.stopword]);
                if (parameters.skipInitialScan !== undefined)
                    args.push('SKIPINITIALSCAN');
            }
            args.push('SCHEMA');
            for (const field of schemaFields) {
                args.push(field.name);
                if (field.as)
                    args = args.concat(['AS', field.as]);
                args.push(field.type);
                if (field.nostem !== undefined)
                    args.push('NOSTEM');
                if (field.weight !== undefined)
                    args = args.concat(['WEIGHT', field.weight.toString()]);
                if (field.phonetic !== undefined)
                    args = args.concat(['PHONETIC', field.phonetic]);
                if (field.seperator !== undefined)
                    args = args.concat(['SEPERATOR', field.seperator]);
                if (field.sortable !== undefined)
                    args.push('SORTABLE');
                if (field.noindex !== undefined)
                    args.push('NOINDEX');
            }
            const response = yield this.sendCommand('FT.CREATE', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Searching the index with a textual query
     * @param index The index
     * @param query The query
     * @param parameters The additional optional parameter
     * @returns Array reply, where the first element is the total number of results, and then pairs of document id, and a nested array of field/value.
     */
    search(index, query, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [index, query];
            if (parameters !== undefined) {
                if (parameters.noContent === true)
                    args.push('NOCONTENT');
                if (parameters.verbatim === true)
                    args.push('VERBARIM');
                if (parameters.noStopWords === true)
                    args.push('NOSTOPWORDS');
                if (parameters.withScores === true)
                    args.push('WITHSCORES');
                if (parameters.withPayloads === true)
                    args.push('WITHPAYLOADS');
                if (parameters.withSortKeys === true)
                    args.push('WITHSORTKEYS');
                if (parameters.filter !== undefined)
                    args = args.concat(['FILTER', parameters.filter.field, parameters.filter.min.toString(), parameters.filter.max.toString()]);
                if (parameters.geoFilter !== undefined)
                    args = args.concat([
                        'GEOFILTER',
                        parameters.geoFilter.field,
                        parameters.geoFilter.lon.toString(),
                        parameters.geoFilter.lat.toString(),
                        parameters.geoFilter.radius.toString(),
                        parameters.geoFilter.measurement
                    ]);
                if (parameters.inKeys !== undefined)
                    args = args.concat(['INKEYS', parameters.inKeys.num.toString(), parameters.inKeys.field]);
                if (parameters.inFields !== undefined)
                    args = args.concat(['INFIELDS', parameters.inFields.num.toString(), parameters.inFields.field]);
                if (parameters.return !== undefined) {
                    args.push('RETURN');
                    if (parameters.return.num)
                        args.push(parameters.return.num.toString());
                    if (parameters.return.fields)
                        parameters.return.fields.forEach(field => {
                            args.push(field.name);
                            if (field.as)
                                args = args.concat(['AS', field.as]);
                        });
                }
                if (parameters.summarize !== undefined) {
                    args.push('SUMMARIZE');
                    if (parameters.summarize.fields !== undefined) {
                        args.push('FIELDS');
                        for (const field of parameters.summarize.fields) {
                            args = args.concat([field.num.toString(), field.field]);
                        }
                    }
                    if (parameters.summarize.frags !== undefined)
                        args = args.concat(['FRAGS', parameters.summarize.frags.toString()]);
                    if (parameters.summarize.len !== undefined)
                        args = args.concat(['LEN', parameters.summarize.len.toString()]);
                    if (parameters.summarize.seperator !== undefined)
                        args = args.concat(['SEPARATOR', parameters.summarize.seperator]);
                }
                if (parameters.highlight !== undefined) {
                    args.push('HIGHLIGHT');
                    if (parameters.highlight.fields !== undefined) {
                        args.push('FIELDS');
                        for (const field of parameters.highlight.fields) {
                            args = args.concat([field.num.toString(), field.field]);
                        }
                    }
                    if (parameters.highlight.tags !== undefined) {
                        args.push('TAGS');
                        for (const tag of parameters.highlight.tags) {
                            args = args.concat([tag.open, tag.close]);
                        }
                    }
                }
                if (parameters.slop !== undefined)
                    args = args.concat(['SLOP', parameters.slop.toString()]);
                if (parameters.inOrder !== undefined)
                    args.push('INORDER');
                if (parameters.language !== undefined)
                    args = args.concat(['LANGUAGE', parameters.language]);
                if (parameters.expander !== undefined)
                    args = args.concat(['EXPANDER', parameters.expander]);
                if (parameters.scorer !== undefined)
                    args = args.concat(['SCORER', parameters.scorer]);
                if (parameters.explainScore !== undefined)
                    args.push('EXPLAINSCORE');
                if (parameters.payload)
                    args = args.concat(['PAYLOAD', parameters.payload]);
                if (parameters.sortBy !== undefined)
                    args = args.concat(['SORTBY', parameters.sortBy.field, parameters.sortBy.sort]);
                if (parameters.limit !== undefined)
                    args = args.concat(['LIMIT', parameters.limit.first.toString(), parameters.limit.num.toString()]);
            }
            const response = yield this.sendCommand('FT.SEARCH', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Runs a search query on an index, and performs aggregate transformations on the results, extracting statistics etc from them
     * @param index The index
     * @param query The query
     * @param parameters The additional optional parameters
     * @returns Array Response. Each row is an array and represents a single aggregate result
     */
    aggregate(index, query, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [index, query];
            if (parameters !== undefined) {
                if (parameters.load !== undefined) {
                    args.push('LOAD');
                    if (parameters.load.nargs !== undefined)
                        args.push(parameters.load.nargs);
                    if (parameters.load.properties !== undefined)
                        parameters.load.properties.forEach(property => {
                            args.push(property);
                        });
                }
                if (parameters.apply !== undefined) {
                    parameters.apply.forEach(apply => {
                        args.push('APPLY');
                        args.push(apply.expression);
                        if (apply.as)
                            args = args.concat(['AS', apply.as]);
                    });
                }
                if (parameters.groupby !== undefined) {
                    args.push('GROUPBY');
                    if (parameters.groupby.nargs !== undefined)
                        args.push(parameters.groupby.nargs);
                    if (parameters.groupby.properties !== undefined) {
                        parameters.groupby.properties.forEach((property) => {
                            args.push(property);
                        });
                    }
                }
                if (parameters.reduce !== undefined) {
                    parameters.reduce.forEach(reduce => {
                        args.push('REDUCE');
                        if (reduce.function !== undefined)
                            args.push(reduce.function);
                        if (reduce.nargs !== undefined)
                            args.push(reduce.nargs);
                        if (reduce.args)
                            reduce.args.forEach(arg => {
                                args.push(arg);
                            });
                        if (reduce.as !== undefined)
                            args = args.concat(['AS', reduce.as]);
                    });
                }
                if (parameters.sortby !== undefined) {
                    args.push('SORTBY');
                    if (parameters.sortby.nargs !== undefined)
                        args.push(parameters.sortby.nargs);
                    if (parameters.sortby.properties)
                        parameters.sortby.properties.forEach(property => {
                            args.push(property.property);
                            args.push(property.sort);
                        });
                    if (parameters.sortby.max !== undefined)
                        args = args.concat(['MAX', parameters.sortby.max.toString()]);
                }
                if (parameters.expressions !== undefined) {
                    parameters.expressions.forEach(expression => {
                        args.push('APPLY');
                        args.push(expression.expression);
                        if (expression.as)
                            args = args.concat(['AS', expression.as]);
                    });
                }
                if (parameters.limit !== undefined) {
                    args.push('LIMIT');
                    if (parameters.limit.offset !== undefined)
                        args.push(parameters.limit.offset);
                    if (parameters.limit.numberOfResults !== undefined)
                        args.push(parameters.limit.numberOfResults.toString());
                }
            }
            const response = yield this.sendCommand('FT.AGGREGATE', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Retrieving the execution plan for a complex query
     * @param index The index
     * @param query The query
     * @returns Returns the execution plan for a complex query
     */
    explain(index, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.EXPLAIN', [index, query]);
            return this.handleResponse(response);
        });
    }
    /**
     * Retrieving the execution plan for a complex query but formatted for easier reading without using redis-cli --raw
     * @param index The index
     * @param query The query
     * @returns A string representing the execution plan.
     */
    explainCLI(index, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.EXPLAINCLI', [index, query]);
            return this.handleResponse(response.join(''));
        });
    }
    /**
     * Adding a new field to the index
     * @param index The index
     * @param field The field name
     * @param fieldType The field type
     * @param options The additional optional parameters
     * @returns 'OK' or error
     */
    alter(index, field, fieldType, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [index, 'SCHEMA', 'ADD', field, fieldType];
            if (options !== undefined) {
                if (options.sortable !== undefined)
                    args.push('SORTABLE');
                if (options.noindex !== undefined)
                    args.push('NOINDEX');
                if (options.nostem !== undefined)
                    args.push('NOSTEM');
                if (options.phonetic !== undefined)
                    args = args.concat(['PHONETIC', options.phonetic]);
                if (options.seperator !== undefined)
                    args = args.concat(['SEPERATOR', options.seperator]);
                if (options.weight !== undefined)
                    args = args.concat(['WEIGHT', options.weight.toString()]);
            }
            const response = yield this.sendCommand('FT.ALTER', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Deleting the index
     * @param index The index
     * @param deleteHash If set, the drop operation will delete the actual document hashes.
     * @returns 'OK' or error
     */
    dropindex(index, deleteHash = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [index];
            if (deleteHash === true)
                args.push('DD');
            const response = yield this.sendCommand('FT.DROPINDEX', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Adding alias fron an index
     * @param name The alias name
     * @param index The alias index
     * @returns 'OK' or error
     */
    aliasadd(name, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.ALIASADD', [name, index]);
            return this.handleResponse(response);
        });
    }
    /**
     * Updating alias index
     * @param name The alias name
     * @param index The alias index
     * @returns 'OK' or error
     */
    aliasupdate(name, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.ALIASUPDATE', [name, index]);
            return this.handleResponse(response);
        });
    }
    /**
     * Deleting alias fron an index
     * @param name The alias name
     * @returns 'OK' or error
     */
    aliasdel(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.ALIASDEL', [name]);
            return this.handleResponse(response);
        });
    }
    /**
     * Retrieving the distinct tags indexed in a Tag field
     * @param index The index
     * @param field The field name
     * @returns The distinct tags indexed in a Tag field
     */
    tagvals(index, field) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.TAGVALS', [index, field]);
            return this.handleResponse(response);
        });
    }
    /**
     * Adds a suggestion string to an auto-complete suggestion dictionary
     * @param key The key
     * @param suggestion The suggestion
     * @param score The score
     * @param options The additional optional parameters
     * @returns The current size of the suggestion dictionary
     */
    sugadd(key, suggestion, score, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, suggestion, score];
            if (options !== undefined &amp;&amp; options.incr !== undefined)
                args.push('INCR');
            if (options !== undefined &amp;&amp; options.payload !== undefined)
                args = args.concat(['PAYLOAD', options.payload]);
            const response = yield this.sendCommand('FT.SUGADD', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Retrieving completion suggestions for a prefix
     * @param key The key
     * @param prefix The prefix of the suggestion
     * @param options The additional optional parameter
     * @returns A list of the top suggestions matching the prefix, optionally with score after each entry
     */
    sugget(key, prefix, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, prefix];
            if (options !== undefined &amp;&amp; options.fuzzy !== undefined)
                args.push('FUZZY');
            if (options !== undefined &amp;&amp; options.max !== undefined)
                args = args.concat(['MAX', options.max.toString()]);
            if (options !== undefined &amp;&amp; options.withScores !== undefined)
                args.push('WITHSCORES');
            if (options !== undefined &amp;&amp; options.withPayloads !== undefined)
                args.push('WITHPAYLOADS');
            const response = yield this.sendCommand('FT.SUGGET', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Deleting a string from a suggestion index
     * @param key The key
     * @param suggestion The suggestion
     */
    sugdel(key, suggestion) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.SUGDEL', [key, suggestion]);
            return this.handleResponse(response);
        });
    }
    /**
     * Retrieving the size of an auto-complete suggestion dictionary
     * @param key The key
     */
    suglen(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.SUGLEN', key);
            return this.handleResponse(response);
        });
    }
    /**
     * Updating a synonym group
     * @param index The index
     * @param groupId The group id
     * @param terms A list of terms
     * @param skipInitialScan If set, we do not scan and index.
     * @returns 'OK'
     */
    synupdate(index, groupId, terms, skipInitialScan = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [index, groupId].concat(terms);
            if (skipInitialScan === true)
                args.push('SKIPINITIALSCAN');
            const response = yield this.sendCommand('FT.SYNUPDATE', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Dumps the contents of a synonym group
     * @param index The index
     * @returns A list of synonym terms and their synonym group ids.
     */
    syndump(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.SYNDUMP', [index]);
            return this.handleResponse(response);
        });
    }
    /**
     * Performs spelling correction on a query
     * @param index The index
     * @param query The query
     * @param options The additional optional parameters
     * @returns An array, in which each element represents a misspelled term from the query
     */
    spellcheck(index, query, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [index, query];
            if (options !== undefined &amp;&amp; options.distance !== undefined)
                args = args.concat(['DISTANCE', options.distance]);
            if (options !== undefined &amp;&amp; options.terms !== undefined) {
                args.push('TERMS');
                for (const term of options.terms) {
                    args = args.concat([term.type, term.dict]);
                }
            }
            const response = yield this.sendCommand('FT.SPELLCHECK', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Adding terms to a dictionary
     * @param dict The dictionary
     * @param terms A list of terms
     * @returns The number of new terms that were added
     */
    dictadd(dict, terms) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.DICTADD', [dict].concat(terms));
            return this.handleResponse(response);
        });
    }
    /**
     * Deleting terms from a dictionary
     * @param dict The dictionary
     * @param terms A list of terms
     * @returns The number of terms that were deleted
     */
    dictdel(dict, terms) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.DICTDEL', [dict].concat(terms));
            return this.handleResponse(response);
        });
    }
    /**
     * Dumps all terms in the given dictionary
     * @param dict The dictionary
     * @returns An array, where each element is term
     */
    dictdump(dict) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.DICTDUMP', [dict]);
            return this.handleResponse(response);
        });
    }
    /**
     * Retrieving infromation and statistics on the index
     * @param index The index
     * @returns A nested array of keys and values.
     */
    info(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('FT.INFO', [index]);
            return this.handleResponse(response);
        });
    }
    /**
     * Retrieves, describes and sets runtime configuration options
     * @param command The command type
     * @param option The option
     * @param value In case of 'SET' command, a valid value to set
     * @returns If 'SET' command, returns 'OK' for valid runtime-settable option names and values. If 'GET' command, returns a string with the current option's value.
     */
    config(command, option, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [command, option];
            if (command === 'SET')
                args.push(value);
            const response = yield this.sendCommand('FT.CONFIG', args);
            return this.handleResponse(response);
        });
    }
}
exports.Redisearch = Redisearch;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#modulePropNames">modulePropNames</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Sep 02 2021 03:06:58 GMT+0300 (Israel Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
