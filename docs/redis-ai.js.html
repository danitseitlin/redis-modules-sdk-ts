<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: redis-ai.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: redis-ai.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisAI = void 0;
const module_base_1 = require("./module.base");
class RedisAI extends module_base_1.Module {
    constructor(options, moduleOptions, clusterOptions) {
        super(RedisAI.name, options, moduleOptions, clusterOptions);
    }
    /**
     * Setting a tensor
     * @param key The tensor's key name
     * @param type The tensor's data type can be one of: FLOAT , DOUBLE , INT8 , INT16 , INT32 , INT64 , UINT8 or UINT16
     * @param data The tensor's data (binary/numberic)
     * @param shape One or more dimensions, or the number of elements per axis, for the tensor
     */
    tensorset(key, type, shapes, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [key, type];
            shapes.forEach(shape => { args.push(shape.toString()); });
            if (data !== undefined) {
                args.push(data instanceof Buffer ? 'BLOB' : 'VALUES');
                data.forEach((value) => { args.push(value.toString()); });
            }
            return yield this.sendCommand('AI.TENSORSET', args);
        });
    }
    /**
     * Retrieving a tensor
     * @param key The tensor's key name
     * @param meta Returns the tensor's metadata
     * @param format The tensor's reply format can be one of the following (BLOB/VALUES)
     */
    tensorget(key, format, meta) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [key];
            if (meta === true)
                args.push('META');
            if (format !== undefined)
                args.push(format);
            const response = yield this.sendCommand('AI.TENSORGET', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Setting a model
     * @param key The model's key name
     * @param backend The backend of the model
     * @param device The devide of the model
     * @param model The Protobuf-serialized model. Since Redis supports strings up to 512MB, blobs for very large
     * @param options Additional optional parameters
     */
    modelstore(key, backend, device, model, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, backend, device];
            if (options !== undefined &amp;&amp; options.tag !== undefined)
                args = args.concat(['TAG', options.tag]);
            if (options !== undefined &amp;&amp; options.batch !== undefined) {
                args = args.concat(['BATCHSIZE', options.batch.size]);
                if (options.batch.minSize !== undefined)
                    args = args.concat(['MINBATCHSIZE', options.batch.minSize]);
            }
            if (options !== undefined &amp;&amp; options.inputs !== undefined &amp;&amp; options.inputs.length > 0)
                args = args.concat(['INPUTS', options.inputsCount].concat(options.inputs));
            if (options !== undefined &amp;&amp; options.outputs !== undefined &amp;&amp; options.outputs.length > 0)
                args = args.concat(['OUTPUTS', options.outputsCount].concat(options.outputs));
            return yield this.sendCommand('AI.MODELSTORE', args.concat(['BLOB', model]));
        });
    }
    /**
     * Retrieving a model
     * @param key The model's key name
     * @param meta Will return the model's meta information on backend, device and tag
     * @param blob Will return the model's blob containing the serialized model
     */
    modelget(key, meta, blob) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [key];
            if (meta === true)
                args.push('META');
            if (blob === true)
                args.push('BLOB');
            const response = yield this.sendCommand('AI.MODELGET', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Deleting a model
     * @param key The model's key name
     */
    modeldel(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('AI.MODELDEL', [key]);
        });
    }
    /**
     * Running a model
     * @param key The model's key name
     * @param parameters The parameters of 'AI.MODELEXECUTE'
     */
    modelexecute(key, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, 'INPUTS', parameters.inputsCount].concat(parameters.inputs).concat(['OUTPUTS', parameters.outputsCount]).concat(parameters.outputs);
            if (parameters.timeout)
                args = args.concat(['TIMEOUT', parameters.timeout]);
            return yield this.sendCommand('AI.MODELEXECUTE', args);
        });
    }
    /**
     * Scanning a model
     */
    modelscan() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('AI._MODELSCAN', []);
        });
    }
    /**
     * Setting a script
     * @param key The script's key name
     * @param parameters Additional optional parameters
     */
    scriptset(key, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, parameters.device];
            if (parameters.tag !== undefined)
                args = args.concat(['TAG', parameters.tag]);
            return yield this.sendCommand('AI.SCRIPTSET', args.concat(['SOURCE', parameters.script]));
        });
    }
    /**
     * Retrieving a script
     * @param key The script's key name
     * @param meta The script's device as a String
     * @param source The script's source code as a String
     */
    scriptget(key, meta, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [key];
            if (meta === true)
                args.push('META');
            if (source === true)
                args.push('SOURCE');
            const response = yield this.sendCommand('AI.SCRIPTGET', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Deleting a script
     * @param key The script's key name
     */
    scriptdel(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('AI.SCRIPTDEL', [key]);
        });
    }
    /**
     * Running a script
     * @param key The script's key nameb
     * @param functionName The name of the function to run
     * @param parameters The parameters of the 'AI.SCRIPTEXECUTE' command
    */
    scriptexecute(key, functionName, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, functionName, 'KEYS', parameters.numberOfKeys].concat(parameters.keys);
            if (parameters.inputs &amp;&amp; parameters.numberOfInputs &amp;&amp; parameters.inputs.length > 0)
                args = args.concat(['INPUTS', parameters.numberOfInputs]).concat(parameters.inputs);
            else if (parameters.listInputs &amp;&amp; parameters.numberOfListInputs &amp;&amp; parameters.listInputs.length > 0)
                args = args.concat('LIST_INPUTS', parameters.numberOfListInputs).concat(parameters.listInputs);
            args = args.concat('OUTPUTS', parameters.numberOfOutputs).concat(parameters.outputs);
            if (parameters.timeout)
                args.concat('TIMEOUT', parameters.timeout);
            return yield this.sendCommand('AI.SCRIPTEXECUTE', args);
        });
    }
    /**
     * Scanning a script
     */
    scriptscan() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('AI._SCRIPTSCAN');
        });
    }
    /**
     * Running a DAG
     * @param parameters Additional parameters required for the 'AI.DAGEXECUTE' command
     * @param commands The commands sent to the 'AI.DAGEXECUTE' command
     */
    dagexecute(parameters, commands) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('AI.DAGEXECUTE', this.generateDagRunArguments(parameters, commands));
        });
    }
    /**
     * Running a readonly DAG
     * @param parameters Additional parameters required for the 'AI.DAGEXECUTE_RO' command
     * @param commands The commands sent to the 'AI.DAGEXECUTE_RO' command
     */
    dagexecuteRO(parameters, commands) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('AI.DAGEXECUTE_RO', this.generateDagRunArguments(parameters, commands));
        });
    }
    /**
     * Generating the dagexecute CLI arguments
     * @param parameters Additional parameters required for the DAG command
     * @param commands The given commands
     */
    generateDagRunArguments(parameters, commands) {
        let args = [];
        args = args.concat([parameters.type.toUpperCase(), `${parameters.numberOfKeys}`].concat(parameters.keys));
        if (parameters.timeout)
            args = args.concat(['TIMEOUT', `${parameters.timeout}`]);
        commands.forEach(command => {
            args = args.concat(['|>'].concat(command.split(' ')));
        });
        console.log(args);
        return args;
    }
    /**
     * Retrieving script/model info
     * @param key The key name of a model or script
     * @param RESETSTAT Resets all statistics associated with the key
     */
    info(key, RESETSTAT) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [key];
            if (RESETSTAT === true)
                args.push('RESETSTAT');
            const response = yield this.sendCommand('AI.INFO', args);
            return this.handleResponse(response);
        });
    }
    /**
     * Restrieving configuration
     * @param path Specifies the default base backends path to path . The backends path is used when dynamically loading a backend (default: '{module_path}/backends', where module_path is the module's path).
     * @param backend  Loads the DL/ML backend specified by the backend identifier from path . If path is relative, it is resolved by prefixing the BACKENDSPATH to it. If path is absolute then it is used as is.
     */
    config(path, backend) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [];
            if (backend !== undefined)
                args = args.concat(['LOADBACKEND', backend, path]);
            else
                args = args.concat(['BACKENDSPATH', path]);
            return yield this.sendCommand('AI.CONFIG', args);
        });
    }
}
exports.RedisAI = RedisAI;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#modulePropNames">modulePropNames</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Sep 02 2021 02:48:31 GMT+0300 (Israel Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
