<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: rts.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: rts.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisTimeSeries = void 0;
const module_base_1 = require("./module.base");
class RedisTimeSeries extends module_base_1.Module {
    constructor(options, moduleOptions, clusterOptions) {
        super(RedisTimeSeries.name, options, moduleOptions, clusterOptions);
    }
    /**
     * Creating a new TS key
     * @param key The key
     * @param options The 'TS.CREATE' optional parameter
     * @param options.retention The 'RETENTION' optional parameter
     * @param options.uncompressed The 'UNCOMPRESSED' optional parameter
     * @param options.chunkSize The 'CHUNK_SIZE' optional parameter
     * @param options.labels A list of 'LABELS' optional parameter
     * @param options.duplicatePolicy The 'DUPLICATE_POLICY' optional parameter
     * @returns "OK"
     */
    create(key, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key];
            if (options !== undefined &amp;&amp; options.retention !== undefined)
                args = args.concat(['RETENTION', options.retention.toString()]);
            if (options !== undefined &amp;&amp; options.uncompressed === true)
                args.push('UNCOMPRESSED');
            if (options !== undefined &amp;&amp; options.chunkSize !== undefined)
                args = args.concat(['CHUNK_SIZE', options.chunkSize.toString()]);
            if (options !== undefined &amp;&amp; options.duplicatePolicy !== undefined)
                args = args.concat(['DUPLICATE_POLICY', options.duplicatePolicy]);
            if (options !== undefined &amp;&amp; options.labels !== undefined &amp;&amp; options.labels.length > 0) {
                args.push('LABELS');
                for (const label of options.labels) {
                    args = args.concat([label.name, label.value]);
                }
            }
            return yield this.sendCommand('TS.CREATE', args);
        });
    }
    /**
     * Altering an existing TS key
     * @param key Required. The key
     * @param retention Optional. The retention time
     * @param labels Optional. The labels to update
     *
     */
    alter(key, retention, labels) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key];
            if (retention !== undefined)
                args = args.concat(['RETENTION', retention.toString()]);
            if (labels !== undefined &amp;&amp; labels.length > 0) {
                args.push('LABELS');
                for (const label of labels) {
                    args = args.concat([label.name, label.value]);
                }
            }
            return yield this.sendCommand('TS.ALTER', args);
        });
    }
    /**
     * Appending/creating a new sample to series
     * @param key The key
     * @param timestamp The timestamp
     * @param value The value
     * @param options The 'TS.ADD' command optional parameters
     * @param options.onDuplicate The 'ON_DUPLICATE' optional parameter
     * @param options.retention The 'RETENTION' optional parameter
     * @param options.uncompressed The 'UNCOMPRESSED' optional parameter
     * @param options.chunkSize The 'CHUNK_SIZE' optional parameter
     * @param options.labels A list of 'LABELS' optional parameter
     */
    add(key, timestamp, value, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, timestamp, value];
            if (options !== undefined &amp;&amp; options.retention !== undefined)
                args = args.concat(['RETENTION', options.retention.toString()]);
            if (options !== undefined &amp;&amp; options.uncompressed === true)
                args.push('UNCOMPRESSED');
            if (options !== undefined &amp;&amp; options.onDuplicate === true)
                args.push('ON_DUPLICATE');
            if (options !== undefined &amp;&amp; options.chunkSize !== undefined)
                args = args.concat(['CHUNK_SIZE', options.chunkSize.toString()]);
            if (options !== undefined &amp;&amp; options.labels !== undefined &amp;&amp; options.labels.length > 0) {
                args.push('LABELS');
                for (const label of options.labels) {
                    args = args.concat([label.name, label.value]);
                }
            }
            return yield this.sendCommand('TS.ADD', args);
        });
    }
    /**
     * Appending new samples to a list of series
     * @param keySets A list of key sets
     * @param keySets.key The key
     * @param keySets.timestamp The timestamp
     * @param keySets.value The value
     */
    madd(keySets) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [];
            for (const keySet of keySets)
                args = args.concat([keySet.key, keySet.timestamp, keySet.value]);
            return yield this.sendCommand('TS.MADD', args);
        });
    }
    /**
     * Creating a new sample that increments the latest sample's value
     * @param key The key
     * @param value The value
     * @param options The 'TS.INCRBY' command optional parameters
     * @param options.timestamp The 'TIMESTAMP' optional parameter
     * @param options.retention The 'RETENTION' optional parameter
     * @param options.uncompressed The 'UNCOMPRESSED' optional parameter
     * @param options.chunkSize The 'CHUNK_SIZE' optional parameter
     * @param options.labels A list of 'LABELS' optional parameter
     */
    incrby(key, value, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, value];
            if (options !== undefined &amp;&amp; options.retention !== undefined)
                args = args.concat(['RETENTION', options.retention.toString()]);
            if (options !== undefined &amp;&amp; options.uncompressed === true)
                args.push('UNCOMPRESSED');
            if (options !== undefined &amp;&amp; options.chunkSize !== undefined)
                args = args.concat(['CHUNK_SIZE', options.chunkSize.toString()]);
            if (options !== undefined &amp;&amp; options.labels !== undefined &amp;&amp; options.labels.length > 0) {
                args.push('LABELS');
                for (const label of options.labels) {
                    args = args.concat([label.name, label.value]);
                }
            }
            return yield this.sendCommand('TS.INCRBY', args);
        });
    }
    /**
     * Creating a new sample that decrements the latest sample's value
     * @param key The key
     * @param value The value
     * @param options The 'TS.DECRBY' command optional parameters
     * @param options.timestamp The 'TIMESTAMP' optional parameter
     * @param options.retention The 'RETENTION' optional parameter
     * @param options.uncompressed The 'UNCOMPRESSED' optional parameter
     * @param options.chunkSize The 'CHUNK_SIZE' optional parameter
     * @param options.labels A list of 'LABELS' optional parameter
     */
    decrby(key, value, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key, value];
            if (options !== undefined &amp;&amp; options.retention !== undefined)
                args = args.concat(['RETENTION', options.retention.toString()]);
            if (options !== undefined &amp;&amp; options.uncompressed === true)
                args.push('UNCOMPRESSED');
            if (options !== undefined &amp;&amp; options.chunkSize !== undefined)
                args = args.concat(['CHUNK_SIZE', options.chunkSize.toString()]);
            if (options !== undefined &amp;&amp; options.labels !== undefined &amp;&amp; options.labels.length > 0) {
                args.push('LABELS');
                for (const label of options.labels) {
                    args = args.concat([label.name, label.value]);
                }
            }
            return yield this.sendCommand('TS.DECRBY', args);
        });
    }
    /**
     * Creating a compaction rule
     * @param parameters The 'TS.CREATERULE' command optional parameters
     * @param options.sourceKey The source key
     * @param options.destKey The dest key
     * @param options.aggregation The aggregation type
     * @param options.timeBucket The time bucket
     */
    createrule(parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [parameters.sourceKey, parameters.destKey, 'AGGREGATION', parameters.aggregation, parameters.timeBucket.toString()];
            return yield this.sendCommand('TS.CREATERULE', args);
        });
    }
    /**
     * Deleting a compaction rule
     * @param sourceKey The source key
     * @param destKey The dest key
     */
    deleterule(sourceKey, destKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('TS.DELETERULE', [sourceKey, destKey]);
        });
    }
    /**
     * Querying a range in forward directions
     * @param key The key
     * @param fromTimestamp The starting timestamp
     * @param toTimestamp The ending timestamp
     * @param options The 'TS.Range' command optional parameters
     * @param options.count The 'COUNT' optional parameter
     * @param options.aggregation The 'AGGREGATION' optional parameter
     * @param options.aggregation.type The type of the 'AGGREGATION' command
     * @param options.aggregation.timeBucket The time bucket of the 'AGGREGATION' command
     */
    range(key, fromTimestamp, toTimestamp, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = this.buildRangeCommand(key, fromTimestamp, toTimestamp, options);
            return yield this.sendCommand('TS.RANGE', args);
        });
    }
    /**
     * Querying a range in reverse directions
     * @param key The key
     * @param fromTimestamp The starting timestamp
     * @param toTimestamp The ending timestamp
     * @param options The 'TS.Range' command optional parameters
     * @param options.count The 'COUNT' optional parameter
     * @param options.aggregation The 'AGGREGATION' optional parameter
     * @param options.aggregation.type The type of the 'AGGREGATION' command
     * @param options.aggregation.timeBucket The time bucket of the 'AGGREGATION' command
     */
    revrange(key, fromTimestamp, toTimestamp, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = this.buildRangeCommand(key, fromTimestamp, toTimestamp, options);
            return yield this.sendCommand('TS.REVRANGE', args);
        });
    }
    /**
     * Building the arguments for 'TS.RANGE'/'TS.REVRANGE' commands
     * @param key The key
     * @param fromTimestamp The starting timestamp
     * @param toTimestamp The ending timestamp
     * @param options The 'TS.RANGE'/'TS.REVRANGE' command optional parameters
     * @returns The arguments of the command
     */
    buildRangeCommand(key, fromTimestamp, toTimestamp, options) {
        let args = [key, fromTimestamp, toTimestamp];
        if ((options === null || options === void 0 ? void 0 : options.filterByTS) !== undefined) {
            args = args.concat(['FILTER_BY_TS', options.filterByTS.join(' ')]);
        }
        if ((options === null || options === void 0 ? void 0 : options.filterByValue) !== undefined) {
            args = args.concat(['FILTER_BY_VALUE', `${options.filterByValue.min}`, `${options.filterByValue.max}`]);
        }
        if ((options === null || options === void 0 ? void 0 : options.count) !== undefined) {
            args = args.concat(['COUNT', `${options.count}`]);
        }
        if ((options === null || options === void 0 ? void 0 : options.align) !== undefined) {
            args = args.concat(['ALIGN', `${options.align}`]);
        }
        if ((options === null || options === void 0 ? void 0 : options.aggregation) !== undefined) {
            args = args.concat(['AGGREGATION', options.aggregation.type, `${options.aggregation.timeBucket}`]);
        }
        return args;
    }
    /**
     * Querying a range across multiple time-series by filters in forward directions
     * @param fromTimestamp The starting timestamp
     * @param toTimestamp The ending timestamp
     * @param filter The filter
     * @param options The 'TS.MRange' command optional parameters
     * @param options.count The 'COUNT' optional parameter
     * @param options.aggregation The 'AGGREGATION' optional parameter
     * @param options.aggregation.type The type of the 'AGGREGATION' command
     * @param options.aggregation.timeBucket The time bucket of the 'AGGREGATION' command
     * @param options.withLabels The 'WITHLABELS' optional parameter
     */
    mrange(fromTimestamp, toTimestamp, filter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = this.buildMultiRangeCommand(fromTimestamp, toTimestamp, filter, options);
            return yield this.sendCommand('TS.MRANGE', args);
        });
    }
    /**
     * Querying a range across multiple time-series by filters in reverse directions
     * @param fromTimestamp The starting timestamp
     * @param toTimestamp The ending timestamp
     * @param filter The filter
     * @param options The 'TS.MRange' command optional parameters
     * @param options.count The 'COUNT' optional parameter
     * @param options.aggregation The 'AGGREGATION' optional parameter
     * @param options.aggregation.type The type of the 'AGGREGATION' command
     * @param options.aggregation.timeBucket The time bucket of the 'AGGREGATION' command
     * @param options.withLabels The 'WITHLABELS' optional parameter
     */
    mrevrange(fromTimestamp, toTimestamp, filter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = this.buildMultiRangeCommand(fromTimestamp, toTimestamp, filter, options);
            return yield this.sendCommand('TS.MREVRANGE', args);
        });
    }
    /**
     * Building the arguments for 'TS.MRANGE'/'TS.MREVRANGE' commands
     * @param fromTimestamp The starting timestamp
     * @param toTimestamp The ending timestamp
     * @param filter The filter
     * @param options The 'TS.MRANGE'/'TS.MREVRANGE' command optional parameters
     * @returns The arguments of the command
     */
    buildMultiRangeCommand(fromTimestamp, toTimestamp, filter, options) {
        let args = [fromTimestamp, toTimestamp];
        if ((options === null || options === void 0 ? void 0 : options.count) !== undefined) {
            args = args.concat(['COUNT', `${options.count}`]);
        }
        if ((options === null || options === void 0 ? void 0 : options.align) !== undefined) {
            args = args.concat(['ALIGN', `${options.align}`]);
        }
        if (options === null || options === void 0 ? void 0 : options.aggregation) {
            args = args.concat(['AGGREGATION', `${options.aggregation.type}`, `${options.aggregation.timeBucket}`]);
        }
        if ((options === null || options === void 0 ? void 0 : options.withLabels) === true) {
            args.push('WITHLABELS');
        }
        args = args.concat(['FILTER', `${filter}`]);
        if (options === null || options === void 0 ? void 0 : options.groupBy) {
            args = args.concat(['GROUPBY', `${options.groupBy.label}`, 'REDUCE', `${options.groupBy.reducer}`]);
        }
        return args;
    }
    /**
     * Retrieving the last sample of a key
     * @param key The key
     */
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('TS.GET', key);
        });
    }
    /**
     * Retrieving the last sample of a key by filter
     * @param filter Required. The filter
     * @param withLabels Optional. If to add the 'WITHLABELS' Optional parameter
     */
    mget(filter, withLabels) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [];
            if (withLabels === true)
                args.push('WITHLABELS');
            args = args.concat(['FILTER', filter]);
            return yield this.sendCommand('TS.MGET', args);
        });
    }
    /**
     * Retrieving information and statistics on the time-series
     * @param key The key
     */
    info(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCommand('TS.INFO', key);
            const info = {};
            for (let i = 0; i &lt; response.length; i += 2) {
                info[response[i]] = response[i + 1];
            }
            return info;
        });
    }
    /**
     * Retrieving all the keys matching the filter list
     * @param filter The filter
     */
    queryindex(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('TS.QUERYINDEX', filter);
        });
    }
    /**
     * Delete data points for a given timeseries and interval range in the form of start and end delete timestamps.
     * @param key Key name for timeseries
     * @param fromTimestamp Start timestamp for the range deletion.
     * @param toTimestamp End timestamp for the range deletion.
     * @returns The count of samples deleted
     */
    del(key, fromTimestamp, toTimestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('TS.DEL', [key, fromTimestamp, toTimestamp]);
        });
    }
}
exports.RedisTimeSeries = RedisTimeSeries;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#modulePropNames">modulePropNames</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Sep 02 2021 02:55:17 GMT+0300 (Israel Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
