<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: redisbloom.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: redisbloom.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisBloom = void 0;
const module_base_1 = require("./module.base");
class RedisBloom extends module_base_1.Module {
    constructor(options, moduleOptions, clusterOptions) {
        super(RedisBloom.name, options, moduleOptions, clusterOptions);
    }
    /**
     * Creating an empty Bloom filter with a given desired error ratio and initial capacity.
     * @param key The key under which the filter is to be found
     * @param errorRate The desired probability for false positives. This should be a decimal value between 0 and 1. For example, for a desired false positive rate of 0.1% (1 in 1000), error_rate should be set to 0.001. The closer this number is to zero, the greater the memory consumption per item and the more CPU usage per operation.
     * @param capacity The number of entries you intend to add to the filter. Performance will begin to degrade after adding more items than this number. The actual degradation will depend on how far the limit has been exceeded. Performance will degrade linearly as the number of entries grow exponentially.
     * @param options The additional optional parameters
     */
    reserve(key, errorRate, capacity, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [key, errorRate, capacity];
            if (options !== undefined &amp;&amp; options.expansion !== undefined)
                args.push(options.expansion);
            if (options !== undefined &amp;&amp; options.nonscaling === true)
                args.push('NONSCALING');
            return yield this.sendCommand('BF.RESERVE', args);
        });
    }
    /**
     * Adding an item to the Bloom Filter, creating the filter if it does not yet exist.
     * @param key The key of the 'BF.ADD' command
     * @param item The item of the 'BF.ADD' command
     */
    add(key, item) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('BF.ADD', [key, item]);
        });
    }
    /**
     * Adding one or more items to the Bloom Filter, creating the filter if it does not yet exist. This command operates identically to BF.ADD except it allows multiple inputs and returns multiple values     * @param key
     * @param items The items of the 'BF.MADD' command
     */
    madd(key, items) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('BF.MADD', [key].concat(items));
        });
    }
    /**
     * Adding one or more items to the bloom filter, by default creating it if it does not yet exist. There are several arguments which may be used to modify this behavior.
     * @param key The key of the 'BF.INSERT' command
     * @param items The items of the 'BF.INSERT' command
     * @param options The additional optional parameters of the 'BF.INSERT' command
     */
    insert(key, items, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [key];
            if (options !== undefined &amp;&amp; options.capacity !== undefined)
                args = args.concat(['CAPACITY', options.capacity.toString()]);
            if (options !== undefined &amp;&amp; options.error !== undefined)
                args = args.concat(['ERROR', options.error]);
            if (options !== undefined &amp;&amp; options.expansion !== undefined)
                args = args.concat(['EXPANSION', options.expansion]);
            if (options !== undefined &amp;&amp; options.nocreate !== undefined)
                args.push('NOCREATE');
            if (options !== undefined &amp;&amp; options.noscaling !== undefined)
                args.push('NOSCALING');
            args.push('ITEMS');
            return yield this.sendCommand('BF.INSERT', args.concat(items));
        });
    }
    /**
     * Determining whether an item may exist in the Bloom Filter or not.
     * @param key The key of the 'BF.EXISTS' command
     * @param item The key of the 'BF.EXISTS' command
     */
    exists(key, item) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('BF.EXISTS', [key, item]);
        });
    }
    /**
     * Determining if one or more items may exist in the filter or not.
     * @param key The key of the 'BF.MEXISTS' command
     * @param items The items of the 'BF.MEXISTS' command
     */
    mexists(key, items) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('BF.MEXISTS', [key].concat(items));
        });
    }
    /**
     * Begining an incremental save of the bloom filter
     * @param key The key of the 'BF.SCANDUMP' command
     * @param iterator The iterator of the 'BF.SCANDUMP' command
     */
    scandump(key, iterator) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('BF.SCANDUMP', [key, iterator]);
        });
    }
    /**
     * Restoring a filter previously saved using SCANDUMP.
     * @param key The key of the 'BF.LOADCHUNK' command
     * @param iterator The iterator of the 'BF.LOADCHUNK' command
     * @param data The data of the 'BF.LOADCHUNK' command
     */
    loadchunk(key, iterator, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('BF.LOADCHUNK', [key, iterator, data]);
        });
    }
    /**
     * Returning information about a key
     * @param key The key of the 'BF.INFO' command
     */
    info(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCommand('BF.INFO', [key]);
        });
    }
}
exports.RedisBloom = RedisBloom;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#modulePropNames">modulePropNames</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Sep 02 2021 02:15:51 GMT+0300 (Israel Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
